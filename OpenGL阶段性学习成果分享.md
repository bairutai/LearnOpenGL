1.OpenGL是什么?

OpenGL是一个图形API，本质上是一些函数，我们可以通过这些函数来操纵GPU帮我们做一些事情，OpenGL的核心是一种规范，它本身并没有像其他开源库一样有代码，所以它不是一个库，举个例子，它只负责告诉显卡生产厂商，你应该支持画三角形的函数，函数参数是三个点，以及颜色，还有该函数的返回值。然后由显卡生产厂商去实现这个函数，一般显卡驱动程序中会包含这些OpenGL规定的函数实现。通常情况下，每个生产厂商的实现都会有轻微的不同，这就是为什么在很多情况下有些代码在基于NVIDIA显卡的驱动程序上可以工作，但在AMD或者其他显卡上有点不同，甚至是有bug。

2.OpenGL原理是什么?

OpenGL自身是一个巨大的状态机(State Machine)：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL上下文(Context)。我们通常使用如下途径去更改OpenGL状态：设置选项，操作缓冲。最后，我们使用当前OpenGL上下文来渲染。

3.上下文(Context)怎么理解?

上下文可以理解为运行一段代码所依赖的环境，举个例子，当我在写一个组装电脑的类时，我应该知道从哪里获取CPU，从哪里获取显卡，从哪里获取键盘鼠标等，上下文则应该为我们提供获取这些数据的接口。在我们的项目中也有上下文的应用，叫SceneContext，通过场景上下文可以获取场景根节点，MapNode节点，View等对象，这些对象是我们实现功能用的最多的。

4.渲染流水线

计算机在渲染的时候，把渲染任务分成了一系列的特定子阶段，这些阶段按照一定的顺序来处理顶点数据，最后生成图像，这些子阶段就构成了渲染流水线。而整个渲染流水线是由CPU和GPU共同来完成的。

从概念上渲染流程分成3个阶段：应用程序阶段、几何阶段、光栅化阶段。其中每个阶段又包含多个子流水线阶段。

- 应用程序阶段

  在该阶段需要应用开发者通过CPU来访问GPU，其调用过程如下:

![img](https://pic2.zhimg.com/80/v2-2ea6c5ff0efa753dc8c4740ea3aa479d_720w.png)

​		这个阶段主要有以下3个任务：

- - 准备好场景数据：如场景物件、光源和相机等。所有需要渲染的数据都需要从硬盘加载到系统内存中，并且网格和顶点数据需要加载到显存中。这是因为显卡对显存的访问更快，而且大多数显卡没有直接访问系统内存的权利。

  - 设置渲染状态：用于指示GPU如何渲染一个物体：如是否开启半透明、是否开启光照、使用什么材质、使用哪个纹理等等。当这些都准备好之后，CPU就可以发送一个命令通知GPU使用指定的状态来渲染给定的数据，这个命令就是DrawCall。

  - 调用DrawCall：DrawCall实际上是一个命令，它的发起方是CPU，接收方是GPU，CPU通过这个命令通知GPU进行渲染并输出图像到屏幕。采用渲染流水线后，CPU与GPU并行工作，独立而不相互依赖。这是通过命令缓冲区来实现的：命令缓冲区维护一个命令队列，CPU向其中发送命令，GPU从中取出命令并执行。命令有很多种，DrawCall是一种，其他命令还有改变渲染状态、设置渲染数据流等。

- 几何阶段和光栅化阶段

  这两个阶段都是在GPU中进行，几何阶段和光栅化阶段共同构成了GPU渲染管线，渲染管线的实现有些是完全由GPU固定死的，我们称之为不可控；有些提供了参数供开发者修改，这称之为可配置；有些则是完全由开发者通过shader语言定义的函数来实现的，这称之为可编程。

  ![img](https://learnopengl-cn.github.io/img/01/04/pipeline.png)

  以上几个渲染阶段每一个阶段的输出都做为下一阶段的输入，所以，如果我们打算从一个着色器向另一个着色器发送数据，我们必须在发送方着色器中声明一个输出，在接收方着色器中声明一个类似的输入。当类型和名字都一样的时候，OpenGL就会把两个变量链接到一起，它们之间就能发送数据了（这是在链接程序对象时完成的）。

  **顶点着色器**

  ```glsl
  #version 330 core
  layout (location = 0) in vec3 aPos; // 位置变量的属性位置值为0
  
  out vec4 vertexColor; // 为片段着色器指定一个颜色输出
  
  void main()
  {
      gl_Position = vec4(aPos, 1.0); // 注意我们如何把一个vec3作为vec4的构造器的参数
      vertexColor = vec4(0.5, 0.0, 0.0, 1.0); // 把输出变量设置为暗红色
  }
  ```

  **片段着色器**

  ```glsl
  #version 330 core
  out vec4 FragColor;
  
  in vec4 vertexColor; // 从顶点着色器传来的输入变量（名称相同、类型相同）
  
  void main()
  {
      FragColor = vertexColor;
  }
  ```


​    GLSL中包含C等其它语言大部分的默认基础数据类型：`int`、`float`、`double`、`uint`和`bool`。GLSL也有两种容器类型分别是向量(Vector)和矩阵(Matrix)

Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，但uniform和顶点属性有些不同。首先，uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。

5.纹理

纹理其实就是一张贴图，比如我们建好了一个房子的模型，往墙壁上贴上砖的纹理，让房子看起来更加逼真。纹理最后的展示也是通过shader来实现的具体代码如下

`uniform sampler2D ourTexture`

`FragColor = texture(ourTexture, TexCoord) * vec4(ourColor, 1.0);`

ourTextture是纹理id，这个同样也是在电脑内存中把图像读入，并进行绑定。texture是glsl内置函数，传入纹理id和纹理坐标，上述代码我的理解是把纹理的像素值取出来与片元本身的颜色做运算，输出最后的颜色。sampler2D是opengl的纹理类型

6.向量和矩阵

向量一个是点乘(Dot Product)，记作ˉ*v*⋅ˉ*k*，另一个是叉乘(Cross Product)，记作ˉ*v*×ˉ*k*。向量的点乘可以计算出两个向量之间的夹角，对两个向量的点乘结果求反余弦函数，可以得到夹角。在glsl中用dot函数来求。向量的叉乘可以用来求与已知2个向量互相正交的向量，在glsl中用cross函数

矩阵可以用来做三维变换

缩放：

![image-20220106160658923](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220106160658923.png)

位移：![image-20220106161732782](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220106161732782.png)

矩阵之间进行相乘可以将变换进行组合，glsl中有mat2,mat3,mat4类型来分别对应2 * 2,3 * 3,4 * 4矩阵

7.坐标系统

为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是模型(Model)、观察(View)、投影(Projection)三个矩阵。我们的顶点坐标起始于局部空间(Local Space)，在这里它称为局部坐标(Local Coordinate)，它在之后会变为世界坐标(World Coordinate)，观察坐标(View Coordinate)，裁剪坐标(Clip Coordinate)，并最后以屏幕坐标(Screen Coordinate)的形式结束。下面的这张图展示了整个流程以及各个变换过程做了什么：

![image](https://learnopengl-cn.github.io/img/01/08/coordinate_systems.png)

我们OSG中自定义的操作器核心其实就是不断的修改第二个步骤中世界坐标转换为观察坐标所乘的ViewMatrix，来模拟我们所观察的物体不断变化的一个过程。OSG操作器的虚函数 getInverseMatrix()，获取逆矩阵，这个其实就是上面所说的ViewMatrix，getMatrix()函数获取相机位置矩阵。这两个矩阵互为逆矩阵

8.摄像机/观察空间

![image](https://learnopengl-cn.github.io/img/01/09/camera_axes.png)

我们模拟一下viewMatrix求解的一个过程。

- 摄像机位置 vec(0,0,2)
- 摄像机方向,摄像机位置-原点位置
- 求摄像机坐标系的x轴，借助上量(0,1,0) ，进行叉乘可以与求出z轴和上量互相正交的x轴;
- 接着再用x轴和摄像机方向向量进行叉乘求出y轴
- ![image-20220106200939438](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220106200939438.png)

以上是原理，OSG中有封装好的函数帮我们去做这件事,lookat函数

9.冯氏光照模型

- 环境光照(Ambient Lighting)：即使在黑暗的情况下，世界上通常也仍然有一些光亮（月亮、远处的光），所以物体几乎永远不会是完全黑暗的。为了模拟这个，我们会使用一个环境光照常量，它永远会给物体一些颜色。

- 漫反射光照(Diffuse Lighting)：模拟光源对物体的方向性影响(Directional Impact)。它是冯氏光照模型中视觉上最显著的分量。物体的某一部分越是正对着光源，它就会越亮。

- 镜面光照(Specular Lighting)：模拟有光泽物体上面出现的亮点。镜面光照的颜色相比于物体的颜色会更倾向于光的颜色。

  这三者的组合模拟了现实世界的光照，在OSG中有对应的灯光设置接口osg::Light setAmbient setDiffuse setSpecular函数

10.多光源

- 点光源 光线会随着距离逐渐衰减。
- 平行光  光源的每条光线就会近似于互相平行，比如太阳光就是平行光
- 聚光 位于环境中某个位置的光源，它只朝一个特定方向而不是所有方向照射光线。这样的结果就是只有在聚光方向的特定半径内的物体才会被照亮，其它的物体都会保持黑暗。聚光很好的例子就是路灯或手电筒。可以设置平滑边缘

11.OpenGL双缓冲机制

​	应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。为了规避这些问题，我们应用双缓冲渲染窗口应用程序。**前**缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在**后**缓冲上绘制。当所有的渲染指令执行完毕后，我们**交换**(Swap)前缓冲和后缓冲，这样图像就立即呈显出来，之前提到的不真实感就消除了。这也是绘制的最后一步，在GLFW中函数名是glfwSwapBuffers();

12.帧缓冲是什么？

​		帧缓冲是用来存储渲染数据的地方，可以理解为显存，几何数据（顶点坐标、纹理坐标等）和纹理经过一系列渲染管道最终计算出屏幕上的所有像素点，它们需要一个地方来存放，这个地方就是帧缓冲。帧缓冲中的数据会被显示器读取来刷新显示。它由许多缓冲区构成，这些缓冲区大致分为：

　　颜色缓冲区：用于绘图的缓冲区，它包含了颜色索引或者RGBA颜色数据。

　　深度缓冲区：存储每个像素的深度值，当启动深度测试时，片段像素深度值和深度缓冲区深度值进行比较，决定片段哪些像素点数据可以替换到颜色缓冲区中。

　　模板缓冲区：就像使用纸板和喷漆一样精确的混图一样，当启动模板测试时，通过模板测试的片段像素点会被替换到颜色缓冲区中，从而显示出来，未通过的则不会保存到颜色缓冲区中，从而达到了过滤的功能。

​		累积缓冲区：累积缓冲区允许你把渲染到颜色缓冲区的值，拷贝到累积缓冲区。在多次拷贝操作到累积缓冲区时，可以用不同方式的把颜色缓冲区内容和当前累积缓冲区的内容进行重复混合

13.离屏渲染是什么？

​	在默认帧缓冲中绘制对象，这叫当前屏幕渲染（On-screen Rendering）。

​	把渲染计算结果放在非默认帧缓冲中，这叫离屏渲染（Off-screen Rendering）。

​	一般要将自定义缓帧缓冲的数据渲染出来，还需要切回默认帧缓冲，取出自定义帧缓冲的颜色附件，再将其渲染。

​	离屏渲染性能消耗是比较大的，从自定义缓冲区转换到系统帧缓冲区比较耗时。

​	我们水利项目当中CEF框架支持两种渲染模式，离屏渲染和当前屏幕渲染

14.模板测试

![image-20220106203511917](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220106203511917.png)

15.深度测试

OpenGL存储它的所有深度信息于一个Z缓冲(Z-buffer)中，也被称为深度缓冲(Depth Buffer)。GLFW会自动为你生成这样一个缓冲（就像它也有一个颜色缓冲来存储输出图像的颜色）。深度值存储在每个片段里面（作为片段的z值），当片段想要输出它的颜色时，OpenGL会将它的深度值和z缓冲进行比较，如果当前的片段在其它片段之后，它将会被丢弃，否则将会覆盖。这个过程称为深度测试(Depth Testing)，它是由OpenGL自动完成的。

![img](https://pic1.zhimg.com/80/v2-1b078f9ac5beee8ec4fc825582626e4c_720w.jpg)

上图是开启深度测试的效果

![img](https://pic4.zhimg.com/80/v2-e05f2ebfbfcb057ee6dea345c53dd4a7_720w.jpg)

这是未开启的效果
